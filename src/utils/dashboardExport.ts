// src/utils/dashboardExport.ts
import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';

// Types
export interface ExportOptions {
  format: 'pdf' | 'png' | 'jpeg' | 'csv' | 'json';
  filename?: string;
  quality?: number;
  width?: number;
  height?: number;
  includeMetadata?: boolean;
}

export interface DashboardExportData {
  title: string;
  description?: string;
  exportedAt: string;
  widgets: WidgetExportData[];
  metadata?: {
    totalViews: number;
    lastUpdated: string;
    version: string;
  };
}

export interface WidgetExportData {
  id: string;
  title: string;
  type: string;
  data: any;
  config: any;
}

export interface ChartExportData {
  chartId: string;
  title: string;
  type: string;
  data: any[];
  series: any[];
  xAxis?: any;
  yAxis?: any;
}

// Dashboard Export Utility Class
export class DashboardExporter {
  static async exportDashboardAsPDF(
    dashboardElement: HTMLElement,
    options: ExportOptions
  ): Promise<void> {
    try {
      // Configure html2canvas options for better quality
      const canvas = await html2canvas(dashboardElement, {
        useCORS: true,
        allowTaint: true,
        scale: 2, // Higher resolution
        backgroundColor: '#ffffff',
        logging: false,
        width: options.width || dashboardElement.scrollWidth,
        height: options.height || dashboardElement.scrollHeight,
        scrollX: 0,
        scrollY: 0
      });

      const imgData = canvas.toDataURL('image/png', options.quality || 0.95);
      const pdf = new jsPDF({
        orientation: canvas.width > canvas.height ? 'landscape' : 'portrait',
        unit: 'mm',
        format: 'a4'
      });

      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      
      // Calculate image dimensions to fit page
      const imgWidth = pageWidth - 20; // 10mm margin on each side
      const imgHeight = (canvas.height * imgWidth) / canvas.width;

      // Add title page if metadata is included
      if (options.includeMetadata) {
        pdf.setFontSize(20);
        pdf.text('Dashboard Export', pageWidth / 2, 30, { align: 'center' });
        
        pdf.setFontSize(12);
        pdf.text(`Exported: ${new Date().toLocaleString()}`, pageWidth / 2, 50, { align: 'center' });
        pdf.text(`Filename: ${options.filename || 'dashboard'}`, pageWidth / 2, 60, { align: 'center' });
        
        pdf.addPage();
      }

      // Handle multi-page PDFs if content is too tall
      if (imgHeight > pageHeight - 20) {
        const totalPages = Math.ceil(imgHeight / (pageHeight - 20));
        
        for (let page = 0; page < totalPages; page++) {
          if (page > 0) pdf.addPage();
          
          const sourceY = page * (pageHeight - 20) * (canvas.height / imgHeight);
          const sourceHeight = Math.min(
            (pageHeight - 20) * (canvas.height / imgHeight),
            canvas.height - sourceY
          );
          
          // Create a temporary canvas for this page section
          const pageCanvas = document.createElement('canvas');
          pageCanvas.width = canvas.width;
          pageCanvas.height = sourceHeight;
          
          const pageCtx = pageCanvas.getContext('2d');
          if (pageCtx) {
            pageCtx.drawImage(
              canvas,
              0, sourceY, canvas.width, sourceHeight,
              0, 0, canvas.width, sourceHeight
            );
            
            const pageImgData = pageCanvas.toDataURL('image/png', options.quality || 0.95);
            const pageImgHeight = (sourceHeight * imgWidth) / canvas.width;
            
            pdf.addImage(pageImgData, 'PNG', 10, 10, imgWidth, pageImgHeight);
          }
        }
      } else {
        pdf.addImage(imgData, 'PNG', 10, 10, imgWidth, imgHeight);
      }

      // Add footer with timestamp
      const totalPages = pdf.getNumberOfPages();
      for (let i = 1; i <= totalPages; i++) {
        pdf.setPage(i);
        pdf.setFontSize(8);
        pdf.text(
          `Generated by CryptoWebb - Page ${i} of ${totalPages}`,
          pageWidth / 2,
          pageHeight - 5,
          { align: 'center' }
        );
      }

      pdf.save(`${options.filename || 'dashboard'}.pdf`);
    } catch (error) {
      console.error('PDF export failed:', error);
      throw new Error('Failed to export dashboard as PDF');
    }
  }

  static async exportDashboardAsImage(
    dashboardElement: HTMLElement,
    options: ExportOptions
  ): Promise<void> {
    try {
      const canvas = await html2canvas(dashboardElement, {
        useCORS: true,
        allowTaint: true,
        scale: 2,
        backgroundColor: '#ffffff',
        logging: false,
        width: options.width || dashboardElement.scrollWidth,
        height: options.height || dashboardElement.scrollHeight
      });

      // Convert canvas to blob
      canvas.toBlob((blob) => {
        if (!blob) {
          throw new Error('Failed to create image blob');
        }

        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${options.filename || 'dashboard'}.${options.format}`;
        link.click();
        
        URL.revokeObjectURL(url);
      }, `image/${options.format}`, options.quality || 0.95);
    } catch (error) {
      console.error('Image export failed:', error);
      throw new Error(`Failed to export dashboard as ${options.format?.toUpperCase()}`);
    }
  }

  static async exportDashboardData(
    dashboardData: DashboardExportData,
    options: ExportOptions
  ): Promise<void> {
    try {
      let content: string;
      let mimeType: string;
      let fileExtension: string;

      switch (options.format) {
        case 'csv':
          content = this.convertToCSV(dashboardData);
          mimeType = 'text/csv';
          fileExtension = 'csv';
          break;

        case 'json':
          content = JSON.stringify(dashboardData, null, 2);
          mimeType = 'application/json';
          fileExtension = 'json';
          break;

        default:
          throw new Error(`Unsupported data export format: ${options.format}`);
      }

      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `${options.filename || 'dashboard-data'}.${fileExtension}`;
      link.click();
      
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Data export failed:', error);
      throw new Error(`Failed to export dashboard data as ${options.format?.toUpperCase()}`);
    }
  }

  static exportChartAsCSV(chartData: ChartExportData, filename?: string): void {
    try {
      let csvContent = '';
      
      // Add chart metadata
      csvContent += `Chart Title,${chartData.title}\n`;
      csvContent += `Chart Type,${chartData.type}\n`;
      csvContent += `Export Date,${new Date().toISOString()}\n`;
      csvContent += '\n';

      // Add data headers and rows
      if (chartData.data && chartData.data.length > 0) {
        const headers = Object.keys(chartData.data[0]);
        csvContent += headers.join(',') + '\n';

        chartData.data.forEach(row => {
          const values = headers.map(header => {
            const value = row[header];
            // Escape commas and quotes in CSV
            if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
              return `"${value.replace(/"/g, '""')}"`;
            }
            return value;
          });
          csvContent += values.join(',') + '\n';
        });
      }

      // Download CSV
      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `${filename || chartData.title || 'chart'}.csv`;
      link.click();
      
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Chart CSV export failed:', error);
      throw new Error('Failed to export chart data as CSV');
    }
  }

  private static convertToCSV(dashboardData: DashboardExportData): string {
    let csvContent = '';
    
    // Dashboard metadata
    csvContent += `Dashboard Export\n`;
    csvContent += `Title,${dashboardData.title}\n`;
    csvContent += `Description,${dashboardData.description || ''}\n`;
    csvContent += `Exported At,${dashboardData.exportedAt}\n`;
    csvContent += `Total Widgets,${dashboardData.widgets.length}\n`;
    csvContent += '\n';

    // Widget summary
    csvContent += `Widget Summary\n`;
    csvContent += `Widget ID,Title,Type,Data Points\n`;
    
    dashboardData.widgets.forEach(widget => {
      const dataPointsCount = Array.isArray(widget.data) ? widget.data.length : 
                              (widget.data && typeof widget.data === 'object') ? Object.keys(widget.data).length : 0;
      csvContent += `${widget.id},${widget.title},${widget.type},${dataPointsCount}\n`;
    });
    
    csvContent += '\n';

    // Individual widget data
    dashboardData.widgets.forEach((widget, index) => {
      csvContent += `Widget ${index + 1}: ${widget.title}\n`;
      csvContent += `Type: ${widget.type}\n`;
      
      if (Array.isArray(widget.data) && widget.data.length > 0) {
        const headers = Object.keys(widget.data[0]);
        csvContent += headers.join(',') + '\n';
        
        widget.data.forEach(row => {
          const values = headers.map(header => {
            const value = row[header];
            if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
              return `"${value.replace(/"/g, '""')}"`;
            }
            return value;
          });
          csvContent += values.join(',') + '\n';
        });
      } else if (widget.data && typeof widget.data === 'object') {
        csvContent += 'Property,Value\n';
        Object.entries(widget.data).forEach(([key, value]) => {
          csvContent += `${key},${value}\n`;
        });
      }
      
      csvContent += '\n';
    });

    return csvContent;
  }

  // Generate professional export filename
  static generateExportFilename(
    title: string,
    format: string,
    includeTimestamp: boolean = true
  ): string {
    const cleanTitle = title.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
    const timestamp = includeTimestamp ? `_${new Date().toISOString().split('T')[0]}` : '';
    return `${cleanTitle}${timestamp}.${format}`;
  }

  // Validate export permissions
  static canExport(userRole: string, dashboardSettings: any): boolean {
    // Check if user has export permissions
    if (userRole === 'admin') return true;
    if (dashboardSettings?.allowDownloads === false) return false;
    if (dashboardSettings?.isPublic === false && userRole !== 'owner') return false;
    
    return true;
  }

  // Get export quality based on user plan
  static getExportQuality(userPlan: string): number {
    switch (userPlan) {
      case 'enterprise':
        return 1.0; // Highest quality
      case 'pro':
        return 0.9; // High quality
      case 'basic':
        return 0.8; // Good quality
      case 'free':
      default:
        return 0.7; // Standard quality
    }
  }

  // Estimate export file size
  static estimateExportSize(
    dashboardElement: HTMLElement,
    format: 'pdf' | 'png' | 'jpeg',
    quality: number = 0.8
  ): { estimatedMB: number; warning?: string } {
    const area = dashboardElement.scrollWidth * dashboardElement.scrollHeight;
    const pixelCount = area * 4; // Assuming 2x scale
    
    let estimatedBytes: number;
    
    switch (format) {
      case 'pdf':
        estimatedBytes = pixelCount * 0.3 * quality; // PDF compression
        break;
      case 'png':
        estimatedBytes = pixelCount * 0.8; // PNG compression
        break;
      case 'jpeg':
        estimatedBytes = pixelCount * 0.2 * quality; // JPEG compression
        break;
      default:
        estimatedBytes = pixelCount;
    }
    
    const estimatedMB = estimatedBytes / (1024 * 1024);
    const warning = estimatedMB > 10 ? 'Large file size detected. Export may take longer.' : undefined;
    
    return { estimatedMB, warning };
  }
}

// Export helper functions
export const exportDashboard = async (
  elementId: string,
  format: ExportOptions['format'],
  options: Partial<ExportOptions> = {}
): Promise<void> => {
  const element = document.getElementById(elementId);
  if (!element) {
    throw new Error(`Element with ID '${elementId}' not found`);
  }

  const exportOptions: ExportOptions = {
    format,
    filename: options.filename || DashboardExporter.generateExportFilename('dashboard', format),
    quality: options.quality || 0.9,
    width: options.width,
    height: options.height,
    includeMetadata: options.includeMetadata ?? true
  };

  switch (format) {
    case 'pdf':
      await DashboardExporter.exportDashboardAsPDF(element, exportOptions);
      break;
    case 'png':
    case 'jpeg':
      await DashboardExporter.exportDashboardAsImage(element, exportOptions);
      break;
    default:
      throw new Error(`Unsupported visual export format: ${format}`);
  }
};

export const exportDashboardData = async (
  data: DashboardExportData,
  format: 'csv' | 'json',
  filename?: string
): Promise<void> => {
  const exportOptions: ExportOptions = {
    format,
    filename: filename || DashboardExporter.generateExportFilename(data.title, format)
  };

  await DashboardExporter.exportDashboardData(data, exportOptions);
};

export const exportChart = (
  chartData: ChartExportData,
  filename?: string
): void => {
  DashboardExporter.exportChartAsCSV(chartData, filename);
};

export default DashboardExporter;